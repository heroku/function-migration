package com.salesforce.functions.proxy.controller;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.salesforce.functions.proxy.config.ProxyConfig;
import com.salesforce.functions.proxy.model.*;
import com.salesforce.functions.proxy.util.InvalidRequestException;
import com.salesforce.functions.proxy.util.Utils;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.UnsupportedEncodingException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.*;

import static com.salesforce.functions.proxy.util.Constants.*;

public class BaseController {
    private static final Logger LOGGER = LoggerFactory.getLogger(BaseController.class);

    @Autowired
    ProxyConfig proxyConfig;

    @Autowired
    RestTemplate restTemplate;

    @Autowired
    Utils utils;

    /**
     * 1. Parse and validate expected context headers
     * 2. Validate caller w/ given accessToken - /userinfo matches OrgId config var
     * 3. Enrich request w/ newly minted token having activated Permission Sets, if applicable.
     *
     * @return
     */
    public FunctionRequestContext handleRequest(HttpHeaders headers) throws InvalidRequestException {
        FunctionRequestContext functionRequestContext = new FunctionRequestContext(headers);
        parseAndValidateHeaders(functionRequestContext);
        validateClient(functionRequestContext);
        enrich(functionRequestContext);
        return functionRequestContext;
    }

    /**
     * Expected headers:
     *  - x-request-id: request id generated by client that tracks the entire request/response
     *  - ce-specversion: version of CloudEvent schema
     *  - ce-id: see x-request-id
     *  - ce-datacontenttype: content type of request
     *  - ce-source: source of request
     *  - ce-type: type of request
     *  - ce-time: origin time of request
     *  - ce-sfcontext: Salesforce context - context of invoking Org
     *  - ce-sffncontext: context of function request
     *
     * @return
     * @throws InvalidRequestException
     */
    protected void parseAndValidateHeaders(FunctionRequestContext functionRequestContext)
            throws InvalidRequestException {
        HttpHeaders headers = functionRequestContext.getHeaders();
        String requestId = headers.getFirst(HEADER_REQUEST_ID);
        if (utils.isBlank(requestId)) {
            throw new InvalidRequestException(HEADER_REQUEST_ID + " not found", 400);
        }
        functionRequestContext.setRequestId(requestId);

        String auth = headers.getFirst(HttpHeaders.AUTHORIZATION);
        if (utils.isBlank(auth)) {
            throw new InvalidRequestException(requestId, HttpHeaders.AUTHORIZATION + " not found", 400);
        }

        if (!auth.startsWith(AUTHORIZATION_BEARER_PREFIX)) {
            throw new InvalidRequestException(requestId, "Invalid " + HttpHeaders.AUTHORIZATION, 400);
        }

        String requestProvidedAccessToken = auth.substring(AUTHORIZATION_BEARER_PREFIX.length());
        if (utils.isBlank(requestProvidedAccessToken)) {
            throw new InvalidRequestException(requestId, HttpHeaders.AUTHORIZATION + " accessToken not found", 400);
        }
        functionRequestContext.setRequestProvidedAccessToken(requestProvidedAccessToken);

        LOGGER.info("Validated request");
        parseAndValidateContexts(functionRequestContext);
    }

    /**
     * Parse and validate 'ce-sffncontext' and 'ce-sfcontext' headers.  See SfFnContext and SfContext.
     *
     * @param functionRequestContext
     */
    protected void parseAndValidateContexts(FunctionRequestContext functionRequestContext)
            throws InvalidRequestException {
        String requestId = functionRequestContext.getRequestId();
        HttpHeaders headers = functionRequestContext.getHeaders();
        SfFnContext sfFnContext =
                parseAndValidateFunctionContext(requestId, headers.getFirst(HEADER_FUNCTION_REQUEST_CONTEXT));
        functionRequestContext.setSfFnContext(sfFnContext);
        SfContext sfContext =
                parseAndValidateSalesforceContext(requestId, headers.getFirst(HEADER_SALESFORCE_CONTEXT));
        functionRequestContext.setSfContext(sfContext);
    }

    /***
     * Parse and validate 'ce-sffncontext' header.
     *
     * @param requestId
     * @param encodedFunctionContextHeader
     * @return SfFnContext
     * @throws InvalidRequestException
     */
    protected SfFnContext parseAndValidateFunctionContext(String requestId, String encodedFunctionContextHeader)
            throws InvalidRequestException {
        if (utils.isBlank(encodedFunctionContextHeader)) {
            throw new InvalidRequestException(requestId, HEADER_FUNCTION_REQUEST_CONTEXT + " not found", 400);
        }

        SfFnContext sfFnContext;
        try {
            sfFnContext = utils.fromEncodedJson(encodedFunctionContextHeader, SfFnContext.class);
        } catch (JsonProcessingException ex) {
            throw new InvalidRequestException(
                    requestId,
                    "Invalid " + HEADER_FUNCTION_REQUEST_CONTEXT + ": " + ex.getMessage(),
                    400);
        }

        sfFnContext.validate(requestId);

        return sfFnContext;
    }

    /**
     * Parse and validate 'ce-sfcontext' header.
     *
     * @param requestId
     * @param encodedSalesforceContextHeader
     * @return SfContext
     * @throws InvalidRequestException
     */
    protected SfContext parseAndValidateSalesforceContext(String requestId, String encodedSalesforceContextHeader)
            throws InvalidRequestException {
        if (utils.isBlank(encodedSalesforceContextHeader)) {
            throw new InvalidRequestException(requestId, HEADER_SALESFORCE_CONTEXT + " not found", 400);
        }

        SfContext salesforceContext;
        try {
            salesforceContext = utils.fromEncodedJson(encodedSalesforceContextHeader, SfContext.class);
        } catch (JsonProcessingException ex) {
            throw new InvalidRequestException(
                    requestId,
                    "Invalid " + HEADER_SALESFORCE_CONTEXT + ": " + ex.getMessage(),
                    400);
        }

        salesforceContext.validate(requestId);

        return salesforceContext;
    }

    /**
     * Validate that requesting org is expected org (orgId18) by using given token to verify org info
     * provided by /userinfo API.
     *
     * Alternative approach that is simpler and efficient send a private key encrypted value and is
     * decrypted w/ a public key and validated by the proxy.
     *
     * @param functionRequestContext
     * @throws InvalidRequestException
     */
    protected void validateClient(FunctionRequestContext functionRequestContext) throws InvalidRequestException {
        String requestId = functionRequestContext.getRequestId();
        String url = functionRequestContext.getSfContext().getUserContext().getSalesforceBaseUrl() + "/services/oauth2/userinfo";
        ResponseEntity<UserInfoResponse> responseEntity = null;
        try {
            HttpEntity<String> entity = new HttpEntity<>(utils.assembleSalesforceAPIHeaders(functionRequestContext));
            responseEntity = restTemplate.exchange(url, HttpMethod.GET, entity, UserInfoResponse.class);
        } catch (Exception ex) {
            throw new InvalidRequestException(requestId,
                                              "Unable to validate request: " + ex.getMessage(),
                                              responseEntity != null ? responseEntity.getStatusCode().value() : 400);
        }

        UserInfoResponse userInfo = responseEntity.getBody();
        if (null == userInfo || responseEntity.getStatusCode() != HttpStatus.OK) {
            throw new InvalidRequestException(requestId, "Unauthorized request", 400);
        }

        String expectedOrgId18 = proxyConfig.getOrgId18();
        if (utils.isBlank(userInfo.getOrganization_id()) || !userInfo.getOrganization_id().equals(expectedOrgId18)) {
            LOGGER.warn("[" + requestId + "] Unauthorized caller from org " + userInfo.getOrganization_id() +
                    ", expected " + expectedOrgId18);
            throw new InvalidRequestException(requestId, "Unauthorized request", 401);
        }

        LOGGER.info("Validated client");
    }

    /**
     * Enrich request with function's accessToken activating session-based Permission Sets, if applicable.
     *
     * @param functionRequestContext
     * @throws InvalidRequestException
     */
    protected void enrich(FunctionRequestContext functionRequestContext) throws InvalidRequestException {
        mintToken(functionRequestContext);
        activateSessionPermSet(functionRequestContext);
        assembleFunctionRequest(functionRequestContext);
    }

    /**
     * Mint and return function's token for requesting user using configured Connected App.
     *
     * If applicable, activate provided session-based Permission Set(s) to token.
     *
     * TODO: Consider caching tokens for given signature: user, connected app, session-based Permission(s).  If cached,
     *       use /services/oauth2/introspect to determine token validity (eg, timeout).
     *
     * @param functionRequestContext
     * @return
     * @throws InvalidRequestException
     */
    protected void mintToken(FunctionRequestContext functionRequestContext) throws InvalidRequestException {
        String requestId = functionRequestContext.getRequestId();
        SfContext.UserContext userContext = functionRequestContext.getSfContext().getUserContext();
        String url = userContext.getSalesforceBaseUrl() + "/services/oauth2/token";
        boolean isTest = url.contains(".sandbox.") || url.contains("c.scratch.vf.force.com");

        String issuer = proxyConfig.getConsumerKey();
        String audience = proxyConfig.getAudience();

        ResponseEntity<OauthExchangeResponse> responseEntity = null;
        try {
            String privateKey = decodePrivateKey(proxyConfig.getEncodedPrivateKey());
            PrivateKey signedKey = generatePrivateKey(privateKey);
            String signedJWT = Jwts.builder()
                    .setIssuer(issuer)
                    .setSubject(userContext.getUsername())
                    .setAudience(audience != null ? audience : (isTest ? SANDBOX_AUDIENCE_URL : PROD_AUDIENCE_URL))
                    .setExpiration(new Date((new Date()).getTime() + 360))
                    .signWith(signedKey, SignatureAlgorithm.RS256)
                    .compact();

            // Assemble payload
            MultiValueMap<String, String> formDataMap = new LinkedMultiValueMap<>();
            formDataMap.add("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer");
            formDataMap.add("assertion", signedJWT);

            // Assemble POST form request
            HttpHeaders headers = new HttpHeaders();
            headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_FORM_URLENCODED_VALUE);
            headers.add(HttpHeaders.AUTHORIZATION, "Bearer " + functionRequestContext.getRequestProvidedAccessToken());
            HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(formDataMap, headers);
            responseEntity = restTemplate.postForEntity(url, entity, OauthExchangeResponse.class);
        } catch (Exception ex) {;
            throw new InvalidRequestException(requestId,
                                              "Unable to mint function token: " + ex.getMessage(),
                                              responseEntity != null ? responseEntity.getStatusCode().value() : 401);
        }

        if (responseEntity.getStatusCode() != HttpStatus.OK) {
            throw new InvalidRequestException(requestId,
                                              "Unable to mint function token",
                                              responseEntity.getStatusCode().value());
        }

        OauthExchangeResponse oauthExchangeResponse = responseEntity.getBody();

        // {"error":"invalid_grant","error_description":"invalid assertion"}
        if (!utils.isBlank(oauthExchangeResponse.getError())) {
            String msg = oauthExchangeResponse.getError() +
                    (!utils.isBlank(oauthExchangeResponse.getError_description())
                            ? " (" + oauthExchangeResponse.getError_description() + ")" : "");
            if (msg.contains("invalid_app_access") || msg.contains("user hasn't approved this consumer")) {
                msg += ". Ensure that the target Connected App is set to \"Admin approved users are pre-authorized\" and user " +
                        userContext.getUsername() + " is assigned to Connected App via a Permission Set";
            }
            throw new InvalidRequestException(requestId,
                                              "Unable to mint function token: " + msg,
                                              401);
        }

        LOGGER.info("Minted function token");
        functionRequestContext.getSfFnContext().setAccessToken(oauthExchangeResponse.getAccess_token());
    }

    /**
     * Activate session-based Permission Sets, if applicable.
     *
     * @param functionRequestContext
     * @throws InvalidRequestException
     */
    protected void activateSessionPermSet(FunctionRequestContext functionRequestContext) throws InvalidRequestException {
        String requestId = functionRequestContext.getRequestId();
        SfFnContext functionContext = functionRequestContext.getSfFnContext();
        SfContext salesforceContext = functionRequestContext.getSfContext();
        SfContext.UserContext userContext = salesforceContext.getUserContext();

        if (utils.isBlank(functionContext.getAccessToken())) {
            throw new InvalidRequestException(requestId,
                                              "Unable activate session-based Permission Sets: function's token not provided",
                                              401);
        }

        List<String> permissionSets = functionContext.getPermissionSets();
        if (permissionSets == null || permissionSets.isEmpty()) {
            LOGGER.info("[" + requestId + "] Skipping session-based Permission Sets activation");
            return;
        }

        // Assemble action payload
        Map<String,Object> inputs = Maps.newHashMap();
        List<ActivatePermSetRequest> toActivatePermSetRequests = Lists.newArrayList();
        inputs.put("inputs", toActivatePermSetRequests);
        permissionSets.forEach(permissionSet -> {
            toActivatePermSetRequests.add(new ActivatePermSetRequest(permissionSet));
        });

        String url = utils.assembleSalesforceAPIUrl(userContext.getSalesforceBaseUrl(),
                salesforceContext.getApiVersion(),
                "/actions/standard/activateSessionPermSet");

        // Assemble POST action request
        ResponseEntity<ActionResponse[]> responseEntity = null;
        try {
            HttpEntity<String> entity = new HttpEntity<>(utils.toJson(inputs),
                                                         utils.assembleSalesforceAPIHeaders(functionRequestContext));
            responseEntity = restTemplate.postForEntity(url, entity, ActionResponse[].class);
        } catch (Exception ex) {
            throw new InvalidRequestException(requestId,
                    "Unable activated session-based Permission Set(s): " +
                            String.join(",", permissionSets) + ex.getMessage(),
                    responseEntity != null ? responseEntity.getStatusCode().value() : 401);
        }

        if (responseEntity.getStatusCode() != HttpStatus.OK) {
            throw new InvalidRequestException(requestId,
                    "Unable activated session-based Permission Set(s): " + String.join(",", permissionSets),
                    responseEntity.getStatusCode().value());
        }

        ActionResponse[] actionResponses = responseEntity.getBody();
        if (actionResponses != null
                && actionResponses.length > 0
                && Arrays.stream(actionResponses).filter(ar -> !ar.isSuccess()).findFirst().isPresent()) {
            // TODO: Include all errors
            ActionResponse failedActionResponse = Arrays.stream(actionResponses)
                                                        .filter(ar -> null != ar.getErrors() && ar.getErrors().size() > 0)
                                                        .findFirst()
                                                        .get();
            throw new InvalidRequestException(requestId,
                    "Unable activated session-based Permission Set(s): " +
                            failedActionResponse != null ? utils.toJsonNoThrow(failedActionResponse.getErrors()) : "unknown",
                    responseEntity.getStatusCode().value());
        }

        LOGGER.info("[" + requestId + "] Successfully activated session-based Permission Set(s): " +
                String.join(",", permissionSets));
    }

    /**
     * Re-assemble the function's context header "ce-sffncontext" setting function's accessToken.
     *
     * REVIEWME: This should use the token provided in the request that uses an Admin-controlled Connected App?
     *
     * @param functionRequestContext
     * @throws InvalidRequestException
     */
    protected void assembleFunctionRequest(FunctionRequestContext functionRequestContext) throws InvalidRequestException {
        String sfFnContext;
        try {
            sfFnContext = utils.toEncodedJson(functionRequestContext.getSfFnContext());
        } catch (JsonProcessingException ex) {
            throw new InvalidRequestException(functionRequestContext.getRequestId(),
                                              "Unable to set " + HEADER_FUNCTION_REQUEST_CONTEXT + " header: " + ex.getMessage(),
                                              401);
        }

        HttpHeaders headers = functionRequestContext.getHeaders();
        headers.remove(HEADER_FUNCTION_REQUEST_CONTEXT);
        List<String> sfFnContextHeaderVal = Lists.newArrayList(sfFnContext);
        headers.put(HEADER_FUNCTION_REQUEST_CONTEXT, sfFnContextHeaderVal);
    }

    private String decodePrivateKey(String encodedPrivateKey) throws UnsupportedEncodingException {
        String privateKey = new String(Base64.getDecoder().decode(encodedPrivateKey), "UTF-8");
        privateKey = privateKey.replaceAll("-----(BEGIN|END)[\\w\\s]*-----", "");
        privateKey = privateKey.replaceAll(" ", "");
        privateKey = privateKey.replaceAll("\n", "");
        return privateKey.trim();
    }

    private PrivateKey generatePrivateKey(String privateKeyStr) throws NoSuchAlgorithmException, InvalidKeySpecException {
        java.security.Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKeyStr));
        KeyFactory kf = KeyFactory.getInstance("RSA");
        return kf.generatePrivate(keySpec);
    }
}